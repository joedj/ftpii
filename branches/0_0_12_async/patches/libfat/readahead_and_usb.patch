This patch incorporates the following patches from sourceforge:
    http://sourceforge.net/tracker/index.php?func=detail&aid=1980595&group_id=114505&atid=668553
    http://sourceforge.net/tracker/index.php?func=detail&aid=1983783&group_id=114505&atid=668553
    http://sourceforge.net/tracker/index.php?func=detail&aid=1991146&group_id=114505&atid=668553
    http://sourceforge.net/tracker/index.php?func=detail&aid=2044210&group_id=114505&atid=668553

diff --git a/source/ogc_io/usbstorage.c b/source/ogc_io/usbstorage.c
new file mode 100644
index 0000000..3f70026
--- /dev/null
+++ source/ogc_io/usbstorage.c
@@ -0,0 +1,178 @@
+/*
+
+	usbstorage.c
+
+	Hardware routines for reading and writing to one usb-storage device
+	connected to the Wii.
+
+ Copyright (c) 2008 Sven "svpe" Peter <svpe@gmx.net>
+	
+ Redistribution and use in source and binary forms, with or without modification,
+ are permitted provided that the following conditions are met:
+
+  1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright notice,
+     this list of conditions and the following disclaimer in the documentation and/or
+     other materials provided with the distribution.
+  3. The name of the author may not be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifdef __wii__
+#include "usbstorage.h"
+
+#define DEVLIST_MAXSIZE	8
+
+#include <gccore.h>
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+
+static usbstorage_handle __usbfd;
+static u8 __lun;
+static u8 __mounted;
+
+bool __usbstorage_IsInserted(void);
+
+bool __usbstorage_Startup(void)
+{
+	USB_Initialize();
+	USBStorage_Initialize();
+	memset(&__usbfd, 0, sizeof(__usbfd));
+	__lun = 0;
+	__mounted = 0;
+
+	return __usbstorage_IsInserted();
+}
+
+bool __usbstorage_IsInserted(void)
+{
+	u8 *buffer;
+	u8 dummy;
+	u8 i, j;
+	u16 vid, pid;
+	s32 maxLun;
+	s32 retval;
+
+	if(__mounted == 1)
+		return true;
+
+	buffer = memalign(32, DEVLIST_MAXSIZE << 3);
+	if(buffer == NULL)
+		return false;
+	memset(buffer, 0, DEVLIST_MAXSIZE << 3);
+	
+	if(USB_GetDeviceList("/dev/usb/oh0", buffer, DEVLIST_MAXSIZE, 0, &dummy) < 0)
+	{
+		free(buffer);
+		return false;
+	}
+
+	for(i = 0; i < DEVLIST_MAXSIZE; i++)
+	{
+		memcpy(&vid, (buffer + (i << 3) + 4), 2);
+		memcpy(&pid, (buffer + (i << 3) + 6), 2);
+		if(vid == 0 || pid == 0)
+			continue;
+
+		if(USBStorage_Open(&__usbfd, "oh0", vid, pid) < 0)
+			continue;
+
+		maxLun = USBStorage_GetMaxLUN(&__usbfd);
+		if(maxLun == USBSTORAGE_ETIMEDOUT)
+			break;
+
+		for(j = 0; j < maxLun; j++)
+		{
+			retval = USBStorage_MountLUN(&__usbfd, j);
+			if(retval == USBSTORAGE_ETIMEDOUT)
+			{
+				USBStorage_Close(&__usbfd);
+				break;
+			}
+
+			if(retval < 0)
+				continue;
+
+			__mounted = 1;
+			__lun = j;
+			i = DEVLIST_MAXSIZE;
+			break;
+		}
+	}
+
+	if(__mounted == 1)
+		return true;
+	return false;
+}
+
+bool __usbstorage_ReadSectors(u32 sector, u32 numSectors, void *buffer)
+{
+	s32 retval;
+
+	if(__mounted != 1)
+		return false;
+
+	retval = USBStorage_Read(&__usbfd, __lun, sector, numSectors, buffer);
+	if(retval == USBSTORAGE_ETIMEDOUT)
+	{
+		__mounted = 0;
+		USBStorage_Close(&__usbfd);
+	}
+	if(retval < 0)
+		return false;
+	return true;
+}
+
+bool __usbstorage_WriteSectors(u32 sector, u32 numSectors, const void *buffer)
+{
+	s32 retval;
+
+	if(__mounted != 1)
+		return false;
+
+	retval = USBStorage_Write(&__usbfd, __lun, sector, numSectors, buffer);
+	if(retval == USBSTORAGE_ETIMEDOUT)
+	{
+		__mounted = 0;
+		USBStorage_Close(&__usbfd);
+	}
+	if(retval < 0)
+		return false;
+	return true;
+}
+
+bool __usbstorage_ClearStatus(void)
+{
+	return true;
+}
+
+bool __usbstorage_Shutdown(void)
+{
+	if(__mounted == 1)
+		USBStorage_Close(&__usbfd);
+	return true;
+}
+
+const IO_INTERFACE __io_usbstorage = {
+	DEVICE_TYPE_WII,
+	FEATURE_MEDIUM_CANREAD | FEATURE_MEDIUM_CANWRITE | FEATURE_WII_USB,
+	(FN_MEDIUM_STARTUP)&__usbstorage_Startup,
+	(FN_MEDIUM_ISINSERTED)&__usbstorage_IsInserted,
+	(FN_MEDIUM_READSECTORS)&__usbstorage_ReadSectors,
+	(FN_MEDIUM_WRITESECTORS)&__usbstorage_WriteSectors,
+	(FN_MEDIUM_CLEARSTATUS)&__usbstorage_ClearStatus,
+	(FN_MEDIUM_SHUTDOWN)&__usbstorage_Shutdown
+};
+
+#endif
diff --git a/source/ogc_io/usbstorage.h b/source/ogc_io/usbstorage.h
new file mode 100644
index 0000000..1259760
--- /dev/null
+++ source/ogc_io/usbstorage.h
@@ -0,0 +1,41 @@
+/*
+
+	usbstorage.h
+
+	Hardware routines for reading and writing to one usb-storage device
+	connected to the Wii.
+
+ Copyright (c) 2008 Sven "svpe" Peter <svpe@gmx.net>
+	
+ Redistribution and use in source and binary forms, with or without modification,
+ are permitted provided that the following conditions are met:
+
+  1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright notice,
+     this list of conditions and the following disclaimer in the documentation and/or
+     other materials provided with the distribution.
+  3. The name of the author may not be used to endorse or promote products derived
+     from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef __USBSTOR_H__
+#define __USBSTOR_H__
+
+#include <gccore.h>
+#include "../disc.h"
+
+
+extern const IO_INTERFACE __io_usbstorage;
+
+#endif
Index: include/fat.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/include/fat.h,v
retrieving revision 1.6
diff -u -w -u -w -r1.6 fat.h
--- include/fat.h	10 May 2008 19:34:41 -0000	1.6
+++ include/fat.h	15 Aug 2008 12:42:28 -0000
@@ -61,7 +61,7 @@
 #endif
 
 #if defined( __wii__ )
-typedef enum {PI_DEFAULT, PI_SDGECKO_A, PI_SDGECKO_B, PI_INTERNAL_SD, PI_CUSTOM, PI_MAX_PARTITIONS } PARTITION_INTERFACE;
+typedef enum {PI_DEFAULT, PI_SDGECKO_A, PI_SDGECKO_B, PI_INTERNAL_SD, PI_USBSTORAGE, PI_CUSTOM, PI_MAX_PARTITIONS } PARTITION_INTERFACE;
 #elif defined(__gamecube__)
 typedef enum {PI_DEFAULT, PI_SDGECKO_A, PI_SDGECKO_B, PI_CUSTOM, PI_MAX_PARTITIONS } PARTITION_INTERFACE;
 #elif defined(NDS)
Index: libogc/include/fat.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/libogc/include/fat.h,v
retrieving revision 1.2
diff -u -w -u -w -r1.2 fat.h
--- libogc/include/fat.h	10 May 2008 19:34:49 -0000	1.2
+++ libogc/include/fat.h	15 Aug 2008 12:42:28 -0000
@@ -38,7 +38,7 @@
 #include <gctypes.h>
 
 #if defined(__wii__)
-typedef enum {PI_DEFAULT, PI_SDGECKO_A, PI_SDGECKO_B, PI_INTERNAL_SD, PI_CUSTOM } PARTITION_INTERFACE;
+typedef enum {PI_DEFAULT, PI_SDGECKO_A, PI_SDGECKO_B, PI_INTERNAL_SD, PI_USBSTORAGE, PI_CUSTOM } PARTITION_INTERFACE;
 #else
 typedef enum {PI_DEFAULT, PI_SDGECKO_A, PI_SDGECKO_B, PI_CUSTOM } PARTITION_INTERFACE;
 #endif
@@ -91,6 +91,14 @@
 */
 bool fatSetDefaultInterface (PARTITION_INTERFACE partitionNumber);
 
+/*
+Allocates a read-ahead cache with the given page size in sectors and number of pages.
+This will take away more memory from your application but will incrase the read speed
+as long as the filesystem isn't fragmentated.
+Use this if you have speed problems.
+*/
+bool fatEnableReadAhead(PARTITION_INTERFACE partitionNumber, u32 numPages, u32 pageSize);
+
 #ifdef __cplusplus
 }
 #endif
Index: source/cache.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/cache.c,v
retrieving revision 1.5
diff -u -w -u -w -r1.5 cache.c
--- source/cache.c	10 May 2008 19:34:41 -0000	1.5
+++ source/cache.c	15 Aug 2008 12:42:28 -0000
@@ -46,8 +46,6 @@
 #include "mem_allocate.h"
 #include "bit_ops.h"
 
-#define CACHE_FREE 0xFFFFFFFF
-
 CACHE* _FAT_cache_constructor (u32 numberOfPages, const IO_INTERFACE* discInterface) {
 	CACHE* cache;
 	u32 i;
@@ -267,3 +265,98 @@
 	}
 }
 
+#ifdef READAHEAD_CACHE
+readahead_cache *_FAT_racache_init(u32 numPages, u32 pageSize)
+{
+	u32 i;
+	readahead_cache *cache;
+
+	cache = _FAT_mem_allocate(sizeof(readahead_cache));
+	cache->numPages = numPages;
+	cache->pageSize = pageSize;
+	cache->pages = _FAT_mem_allocate(sizeof(readahead_cache_page) * numPages);
+
+	for(i = 0; i < numPages; i++)
+	{
+		cache->pages[i].sector = CACHE_FREE;
+		cache->pages[i].count = 0;
+		cache->pages[i].ptr = _FAT_mem_allocate_aligned(32, BYTES_PER_READ * pageSize);
+		memset(cache->pages[i].ptr, 0, BYTES_PER_READ * pageSize);
+		if(cache->pages[i].ptr == NULL)
+		{
+			if(i - 1 > 0)
+				cache->numPages = i - 1;
+			else
+				cache->numPages = 0;
+			break;
+		}
+	}
+
+	if(cache->numPages == 0)
+	{
+		_FAT_mem_free(cache->pages);
+		_FAT_mem_free(cache);
+		cache = NULL;
+	}
+
+	return cache;
+}
+
+bool _FAT_racache_readSectors(readahead_cache *cache, const IO_INTERFACE *disc, u32 sector, u32 numSectors, void *buffer)
+{
+	u32 i;
+	u32 leastUsed;
+
+	if(cache == NULL)
+		return _FAT_disc_readSectors(disc, sector, numSectors, buffer);
+
+	leastUsed = 0;
+	for(i = 0; i < cache->numPages; i++)
+	{
+		// TODO: also read if only beginning is in cache
+		if(cache->pages[i].sector <= sector && (cache->pages[i].sector + cache->pageSize) > (sector + numSectors))
+		{
+			memcpy(buffer, cache->pages[i].ptr + ((sector - cache->pages[i].sector) * BYTES_PER_READ), numSectors * BYTES_PER_READ);
+			cache->pages[i].count++;
+			return true;
+		}
+
+		if(cache->pages[i].count <= cache->pages[leastUsed].count)
+			leastUsed = i;
+	}
+
+	for(; i < cache->numPages; i++)
+	{
+		if(cache->pages[i].count <= cache->pages[leastUsed].count)
+			leastUsed = i;
+	}
+
+	if(_FAT_disc_readSectors(disc, sector, cache->pageSize, cache->pages[leastUsed].ptr) == true)
+	{
+		cache->pages[leastUsed].count = 0;
+		cache->pages[leastUsed].sector = sector;
+		memcpy(buffer, cache->pages[leastUsed].ptr, numSectors * BYTES_PER_READ);
+		return true;
+	}
+	else
+	{
+		cache->pages[leastUsed].count = 0;
+		cache->pages[leastUsed].sector = CACHE_FREE;
+		return false;
+	}
+}
+
+void _FAT_racache_free(readahead_cache *cache)
+{
+	u32 i;
+
+	if(cache == NULL)
+		return;
+
+	for(i = 0; i < cache->numPages; i++)
+		_FAT_mem_free(cache->pages[i].ptr);
+
+	_FAT_mem_free(cache->pages);
+	_FAT_mem_free(cache);
+}
+#endif
Index: source/cache.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/cache.h,v
retrieving revision 1.5
diff -u -w -u -w -r1.5 cache.h
--- source/cache.h	10 May 2008 19:34:41 -0000	1.5
+++ source/cache.h	15 Aug 2008 12:42:28 -0000
@@ -43,6 +43,7 @@
 #include "disc.h"
 
 #define CACHE_PAGE_SIZE BYTES_PER_READ
+#define CACHE_FREE 0xFFFFFFFF
 
 typedef struct {
 	u32 sector;
@@ -57,6 +58,20 @@
 	u8* pages;
 } CACHE;
 
+typedef struct
+{
+	u32 sector;
+	u32 count;
+	void *ptr;
+} readahead_cache_page;
+
+typedef struct
+{
+	u32 numPages;
+	u32 pageSize;
+	readahead_cache_page *pages;
+} readahead_cache;
+
 
 /*
 Read data from a sector in the cache
@@ -119,5 +134,30 @@
 
 void _FAT_cache_destructor (CACHE* cache);
 
+#ifdef READAHEAD_CACHE
+
+readahead_cache *_FAT_racache_init(u32 numPages, u32 pageSize);
+bool _FAT_racache_readSectors(readahead_cache *cache, const IO_INTERFACE *disc, u32 sector, u32 numSectors, void *buffer);
+void _FAT_racache_free(readahead_cache *cache);
+
+#else
+
+static inline bool _FAT_racache_readSectors(readahead_cache *cache, const IO_INTERFACE *disc, u32 sector, u32 numSectors, void *buffer)
+{
+	return _FAT_disc_readSectors(disc, sector, numSectors, buffer);
+}
+
+static inline bool _FAT_reache_free(readahead_cache *cache)
+{
+	return true;
+}
+
+readahead_cache *_FAT_racache_init(u32 numPages, u32 pageSize)
+{
+	return NULL;
+}
+
+#endif
+
 #endif // _CACHE_H
 
Index: source/common.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/common.h,v
retrieving revision 1.4
diff -u -w -u -w -r1.4 common.h
--- source/common.h	10 May 2008 19:34:41 -0000	1.4
+++ source/common.h	15 Aug 2008 12:42:28 -0000
@@ -41,6 +41,7 @@
 
 #if defined(__gamecube__) || defined (__wii__)
    #include <gctypes.h>
+   #define READAHEAD_CACHE
 #else
 #  ifdef NDS
    #include <nds/ndstypes.h>
Index: source/directory.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/directory.c,v
retrieving revision 1.14
diff -u -w -u -w -r1.14 directory.c
--- source/directory.c	2 Aug 2008 04:22:47 -0000	1.14
+++ source/directory.c	15 Aug 2008 12:42:29 -0000
@@ -636,13 +636,6 @@
 	}
 
 	if (found && !notFound) {
-		if (partition->filesysType == FS_FAT32 && (entry->entryData[DIR_ENTRY_attributes] & ATTRIB_DIR) &&
-			_FAT_directory_entryGetCluster (entry->entryData) == CLUSTER_ROOT) 
-		{
-			// On FAT32 it should specify an actual cluster for the root entry,
-			// not cluster 0 as on FAT16
-			_FAT_directory_getRootEntry (partition, entry);
-		}
 		return true;
 	} else {
 		return false;
Index: source/disc.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/disc.h,v
retrieving revision 1.1
diff -u -w -u -w -r1.1 disc.h
--- source/disc.h	10 May 2008 19:34:41 -0000	1.1
+++ source/disc.h	15 Aug 2008 12:42:29 -0000
@@ -59,6 +59,8 @@
 #define FEATURE_SLOT_NDS			0x00000020
 #define FEATURE_GAMECUBE_SLOTA		0x00000010
 #define FEATURE_GAMECUBE_SLOTB		0x00000020
+#define FEATURE_WII_SD			0x00000100
+#define FEATURE_WII_USB			0x00000200
 
 typedef bool (* FN_MEDIUM_STARTUP)(void) ;
 typedef bool (* FN_MEDIUM_ISINSERTED)(void) ;
Index: source/fatfile.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/fatfile.c,v
retrieving revision 1.14
diff -u -w -u -w -r1.14 fatfile.c
--- source/fatfile.c	23 May 2008 19:37:46 -0000	1.14
+++ source/fatfile.c	15 Aug 2008 12:42:29 -0000
@@ -388,7 +391,7 @@
 	}
 
 	if ((tempVar > 0) && flagNoError) {
-		if (! _FAT_disc_readSectors (partition->disc, _FAT_fat_clusterToSector (partition, position.cluster) + position.sector,
+		if (! _FAT_racache_readSectors (partition->racache, partition->disc, _FAT_fat_clusterToSector (partition, position.cluster) + position.sector,
 			tempVar, ptr)) 
 		{
 			flagNoError = false;
@@ -417,8 +420,8 @@
 
 	// Read in whole clusters
 	while ((remain >= partition->bytesPerCluster) && flagNoError) {
-		if ( !_FAT_disc_readSectors (
-				partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
+		if ( !_FAT_racache_readSectors (
+				partition->racache, partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
 				partition->sectorsPerCluster, ptr)) 
 		{
 			flagNoError = false;
@@ -444,7 +447,7 @@
 	// Read remaining sectors
 	tempVar = remain / BYTES_PER_READ; // Number of sectors left
 	if ((tempVar > 0) && flagNoError) {
-		if (!_FAT_disc_readSectors (partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
+		if (!_FAT_racache_readSectors (partition->racache, partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
 			tempVar, ptr))
 		{
 			flagNoError = false;
@@ -587,7 +590,7 @@
 	
 	int tempVar;
 
-	u32 remain;
+	u32 remain, i;
 
 	bool flagNoError = true;
 	bool flagAppending = false;
@@ -805,6 +808,14 @@
 		}
 	}
 	
+	// invalidate read-ahaed cache
+	if (partition->racache) {
+		for (i = 0; i < partition->racache->numPages; ++i) {
+			partition->racache->pages[i].count = 0;
+			partition->racache->pages[i].sector = CACHE_FREE;
+		}
+	}
+
 	_FAT_unlock();
 
 	return len;
Index: source/mem_allocate.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/mem_allocate.h,v
retrieving revision 1.1
diff -u -w -u -w -r1.1 mem_allocate.h
--- source/mem_allocate.h	14 Jul 2006 02:42:36 -0000	1.1
+++ source/mem_allocate.h	15 Aug 2008 12:42:29 -0000
@@ -40,6 +40,11 @@
 	return malloc (size);
 }
 
+static inline void* _FAT_mem_allocate_aligned(size_t alignment, size_t size)
+{
+	return memalign(alignment, size);
+}
+
 static inline void _FAT_mem_free (void* mem) {
 	return free (mem);
 }
Index: source/partition.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/partition.c,v
retrieving revision 1.6
diff -u -w -u -w -r1.6 partition.c
--- source/partition.c	10 May 2008 19:34:41 -0000	1.6
+++ source/partition.c	15 Aug 2008 12:42:29 -0000
@@ -103,7 +103,7 @@
 };
 
 #if defined(__wii__)
-#define MAXIMUM_PARTITIONS 5
+#define MAXIMUM_PARTITIONS 6
 #elif defined(__gamecube__)
 #define MAXIMUM_PARTITIONS 4
 #elif defined(NDS)
@@ -162,6 +162,13 @@
 		return NULL;
 	}
 
+	// check again for the last two cases to make damn sure that we really have a FAT filesystem here
+	// and won't corrupt any data
+	if(memcmp(sectorBuffer + BPB_FAT16_fileSysType, "FAT", 3) != 0 && memcmp(sectorBuffer + BPB_FAT32_fileSysType, "FAT32", 5) != 0)
+	{
+		return NULL;
+	}
+
 	partition = (PARTITION*) _FAT_mem_allocate (sizeof(PARTITION));
 	if (partition == NULL) {
 		return NULL;
@@ -218,6 +225,8 @@
 	// Create a cache to use
 	partition->cache = _FAT_cache_constructor (cacheSize, partition->disc);
 
+	partition->racache = NULL;
+
 	// Set current directory to the root
 	partition->cwdCluster = partition->rootDirCluster;
 	
@@ -231,6 +240,7 @@
 }
 
 static void _FAT_partition_destructor (PARTITION* partition) {
+	_FAT_racache_free(partition->racache);
 	_FAT_cache_destructor (partition->cache);
 	_FAT_disc_shutdown (partition->disc);
 	_FAT_mem_free (partition);
@@ -422,3 +432,20 @@
 	return _FAT_partitions[partitionNumber];
 #endif
 }
+
+#ifdef READAHEAD_CACHE
+bool fatEnableReadAhead(PARTITION_INTERFACE partitionNumber, u32 numPages, u32 pageSize)
+{
+	if ((partitionNumber >= MAXIMUM_PARTITIONS)) {
+		return false;
+	}
+
+	if (_FAT_partitions[partitionNumber] == NULL) {
+		return false;
+	}
+
+	_FAT_partitions[partitionNumber]->racache = _FAT_racache_init(numPages, pageSize);
+
+	return true;
+}
+#endif
Index: source/partition.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/partition.h,v
retrieving revision 1.3
diff -u -w -u -w -r1.3 partition.h
--- source/partition.h	10 May 2008 19:34:41 -0000	1.3
+++ source/partition.h	15 Aug 2008 12:42:29 -0000
@@ -53,6 +53,7 @@
 typedef struct {
 	const IO_INTERFACE* disc;
 	CACHE* cache;
+	readahead_cache *racache;
 	// Info about the partition
 	bool readOnly;		// If this is set, then do not try writing to the disc
 	FS_TYPE filesysType;
Index: source/ogc_io/disc.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/ogc_io/disc.c,v
retrieving revision 1.2
diff -u -w -u -w -r1.2 disc.c
--- source/ogc_io/disc.c	25 May 2008 14:52:04 -0000	1.2
+++ source/ogc_io/disc.c	15 Aug 2008 12:42:29 -0000
@@ -76,6 +76,7 @@
 #include "../disc.h"
 #include "wiisd.h"
 #include "gcsd.h"
+#include "usbstorage.h"
 
 
 const IO_INTERFACE* ioInterfaces[] = {
@@ -84,17 +85,18 @@
 	&__io_gcsdb,
 #endif
 #ifdef __wii__
-	&__io_wiisd
+	&__io_wiisd,
+	&__io_usbstorage
 #endif
 };
 
 #ifdef __wii__
-const IO_INTERFACE* _FAT_disc_wiiFindInterface(void)
+const IO_INTERFACE* _FAT_disc_wiiFindInterface(int feature)
 {
 	int i;
 
 	for (i = 0; i < (sizeof(ioInterfaces) / sizeof(IO_INTERFACE*)); i++) {
-		if ((ioInterfaces[i]->ioType == DEVICE_TYPE_WII) && (ioInterfaces[i]->fn_startup())) {
+		if ((ioInterfaces[i]->ioType == DEVICE_TYPE_WII) && ((ioInterfaces[i]->features & feature) == feature) && (ioInterfaces[i]->fn_startup())) {
 			return ioInterfaces[i];
 		}
 	}
@@ -139,7 +141,7 @@
 const IO_INTERFACE* _FAT_disc_findInterface(void)
 {
 #ifdef __wii__
-	return _FAT_disc_wiiFindInterface();
+	return _FAT_disc_wiiFindInterface(0);
 #else
 	return _FAT_disc_gcFindInterface();
 #endif
@@ -159,7 +161,10 @@
 #endif
 #ifdef __wii__
 		case PI_INTERNAL_SD:
-			return _FAT_disc_wiiFindInterface();
+			return _FAT_disc_wiiFindInterface(FEATURE_WII_SD);
+			break;
+		case PI_USBSTORAGE:
+			return _FAT_disc_wiiFindInterface(FEATURE_WII_USB);
 			break;
 #endif
 		default:
Index: source/ogc_io/wiisd.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/ogc_io/wiisd.c,v
retrieving revision 1.1
diff -u -w -u -w -r1.1 wiisd.c
--- source/ogc_io/wiisd.c	10 May 2008 19:35:18 -0000	1.1
+++ source/ogc_io/wiisd.c	15 Aug 2008 12:42:29 -0000
@@ -40,7 +40,7 @@
 
 const IO_INTERFACE __io_wiisd = {
 	DEVICE_TYPE_WII,
-	FEATURE_MEDIUM_CANREAD | FEATURE_MEDIUM_CANWRITE,
+	FEATURE_MEDIUM_CANREAD | FEATURE_MEDIUM_CANWRITE | FEATURE_WII_SD,
 	(FN_MEDIUM_STARTUP)&sdio_Startup,
 	(FN_MEDIUM_ISINSERTED)&sdio_IsInserted,
 	(FN_MEDIUM_READSECTORS)&sdio_ReadSectors,
