Index: libogc/include/fat.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/libogc/include/fat.h,v
retrieving revision 1.3
diff -u -w -r1.3 fat.h
--- libogc/include/fat.h	20 Nov 2008 05:22:19 -0000	1.3
+++ libogc/include/fat.h	21 Dec 2008 03:20:57 -0000
@@ -74,6 +74,14 @@
 */
 extern void fatUnmount (const char* name);
 
+/*
+Allocates a read-ahead cache with the given page size in sectors and number of pages.
+This will take away more memory from your application but will incrase the read speed
+as long as the filesystem isn't fragmentated.
+Use this if you have speed problems.
+*/
+bool fatEnableReadAhead(const char *path, u32 numPages, u32 pageSize);
+
 #ifdef __cplusplus
 }
 #endif
Index: source/cache.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/cache.c,v
retrieving revision 1.6
diff -u -w -r1.6 cache.c
--- source/cache.c	20 Nov 2008 05:22:22 -0000	1.6
+++ source/cache.c	21 Dec 2008 03:20:57 -0000
@@ -43,8 +43,6 @@
 #include "mem_allocate.h"
 #include "bit_ops.h"
 
-#define CACHE_FREE UINT_MAX
-
 CACHE* _FAT_cache_constructor (unsigned int numberOfPages, const DISC_INTERFACE* discInterface) {
 	CACHE* cache;
 	unsigned int i;
@@ -264,3 +262,98 @@
 	}
 }
 
+#ifdef READAHEAD_CACHE
+readahead_cache *_FAT_racache_init(u32 numPages, u32 pageSize)
+{
+	u32 i;
+	readahead_cache *cache;
+
+	cache = _FAT_mem_allocate(sizeof(readahead_cache));
+	cache->numPages = numPages;
+	cache->pageSize = pageSize;
+	cache->pages = _FAT_mem_allocate(sizeof(readahead_cache_page) * numPages);
+
+	for(i = 0; i < numPages; i++)
+	{
+		cache->pages[i].sector = CACHE_FREE;
+		cache->pages[i].count = 0;
+		cache->pages[i].ptr = _FAT_mem_allocate_aligned(32, BYTES_PER_READ * pageSize);
+		memset(cache->pages[i].ptr, 0, BYTES_PER_READ * pageSize);
+		if(cache->pages[i].ptr == NULL)
+		{
+			if(i - 1 > 0)
+				cache->numPages = i - 1;
+			else
+				cache->numPages = 0;
+			break;
+		}
+	}
+
+	if(cache->numPages == 0)
+	{
+		_FAT_mem_free(cache->pages);
+		_FAT_mem_free(cache);
+		cache = NULL;
+	}
+
+	return cache;
+}
+
+bool _FAT_racache_readSectors(readahead_cache *cache, const DISC_INTERFACE *disc, u32 sector, u32 numSectors, void *buffer)
+{
+	u32 i;
+	u32 leastUsed;
+
+	if(cache == NULL)
+		return _FAT_disc_readSectors(disc, sector, numSectors, buffer);
+
+	leastUsed = 0;
+	for(i = 0; i < cache->numPages; i++)
+	{
+		// TODO: also read if only beginning is in cache
+		if(cache->pages[i].sector <= sector && (cache->pages[i].sector + cache->pageSize) > (sector + numSectors))
+		{
+			memcpy(buffer, cache->pages[i].ptr + ((sector - cache->pages[i].sector) * BYTES_PER_READ), numSectors * BYTES_PER_READ);
+			cache->pages[i].count++;
+			return true;
+		}
+
+		if(cache->pages[i].count <= cache->pages[leastUsed].count)
+			leastUsed = i;
+	}
+
+	for(; i < cache->numPages; i++)
+	{
+		if(cache->pages[i].count <= cache->pages[leastUsed].count)
+			leastUsed = i;
+	}
+
+	if(_FAT_disc_readSectors(disc, sector, cache->pageSize, cache->pages[leastUsed].ptr) == true)
+	{
+		cache->pages[leastUsed].count = 0;
+		cache->pages[leastUsed].sector = sector;
+		memcpy(buffer, cache->pages[leastUsed].ptr, numSectors * BYTES_PER_READ);
+		return true;
+	}
+	else
+	{
+		cache->pages[leastUsed].count = 0;
+		cache->pages[leastUsed].sector = CACHE_FREE;
+		return false;
+	}
+}
+
+void _FAT_racache_free(readahead_cache *cache)
+{
+	u32 i;
+
+	if(cache == NULL)
+		return;
+
+	for(i = 0; i < cache->numPages; i++)
+		_FAT_mem_free(cache->pages[i].ptr);
+
+	_FAT_mem_free(cache->pages);
+	_FAT_mem_free(cache);
+}
+#endif
Index: source/cache.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/cache.h,v
retrieving revision 1.6
diff -u -w -r1.6 cache.h
--- source/cache.h	20 Nov 2008 05:22:22 -0000	1.6
+++ source/cache.h	21 Dec 2008 03:20:57 -0000
@@ -40,6 +40,7 @@
 #include "disc.h"
 
 #define CACHE_PAGE_SIZE BYTES_PER_READ
+#define CACHE_FREE 0xFFFFFFFF
 
 typedef struct {
 	sec_t        sector;
@@ -54,6 +55,20 @@
 	uint8_t*              pages;
 } CACHE;
 
+typedef struct
+{
+	u32 sector;
+	u32 count;
+	void *ptr;
+} readahead_cache_page;
+
+typedef struct
+{
+	u32 numPages;
+	u32 pageSize;
+	readahead_cache_page *pages;
+} readahead_cache;
+
 
 /*
 Read data from a sector in the cache
@@ -116,5 +131,30 @@
 
 void _FAT_cache_destructor (CACHE* cache);
 
+#ifdef READAHEAD_CACHE
+
+readahead_cache *_FAT_racache_init(u32 numPages, u32 pageSize);
+bool _FAT_racache_readSectors(readahead_cache *cache, const DISC_INTERFACE *disc, u32 sector, u32 numSectors, void *buffer);
+void _FAT_racache_free(readahead_cache *cache);
+
+#else
+
+static inline bool _FAT_racache_readSectors(readahead_cache *cache, const DISC_INTERFACE *disc, u32 sector, u32 numSectors, void *buffer)
+{
+	return _FAT_disc_readSectors(disc, sector, numSectors, buffer);
+}
+
+static inline bool _FAT_reache_free(readahead_cache *cache)
+{
+	return true;
+}
+
+readahead_cache *_FAT_racache_init(u32 numPages, u32 pageSize)
+{
+	return NULL;
+}
+
+#endif
+
 #endif // _CACHE_H
 
Index: source/common.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/common.h,v
retrieving revision 1.6
diff -u -w -r1.6 common.h
--- source/common.h	22 Nov 2008 13:37:16 -0000	1.6
+++ source/common.h	21 Dec 2008 03:20:57 -0000
@@ -46,6 +46,7 @@
    #include <gctypes.h>
    #include <ogc/disc_io.h>
    #include <gccore.h>
+   #define READAHEAD_CACHE
 #elif defined(NDS)
    #include <nds/ndstypes.h>
    #include <nds/system.h>
Index: source/fatfile.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/fatfile.c,v
retrieving revision 1.21
diff -u -w -r1.21 fatfile.c
--- source/fatfile.c	13 Dec 2008 03:14:54 -0000	1.21
+++ source/fatfile.c	21 Dec 2008 03:20:58 -0000
@@ -406,7 +406,7 @@
 	}
 
 	if ((tempVar > 0) && flagNoError) {
-		if (! _FAT_disc_readSectors (partition->disc, _FAT_fat_clusterToSector (partition, position.cluster) + position.sector,
+		if (! _FAT_racache_readSectors (partition->racache, partition->disc, _FAT_fat_clusterToSector (partition, position.cluster) + position.sector,
 			tempVar, ptr)) 
 		{
 			flagNoError = false;
@@ -449,7 +449,8 @@
 #endif
 			(chunkSize + partition->bytesPerCluster <= remain));
 		
-		if (!_FAT_disc_readSectors (partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
+		if ( !_FAT_racache_readSectors (
+				partition->racache, partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
 				chunkSize / BYTES_PER_READ, ptr)) 
 		{
 			flagNoError = false;
@@ -475,7 +476,7 @@
 	// Read remaining sectors
 	tempVar = remain / BYTES_PER_READ; // Number of sectors left
 	if ((tempVar > 0) && flagNoError) {
-		if (!_FAT_disc_readSectors (partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
+		if (!_FAT_racache_readSectors (partition->racache, partition->disc, _FAT_fat_clusterToSector (partition, position.cluster),
 			tempVar, ptr))
 		{
 			flagNoError = false;
@@ -845,6 +846,15 @@
 		}
 	}
 	
+	// invalidate read-ahaed cache
+	if (partition->racache) {
+		u32 i;
+		for (i = 0; i < partition->racache->numPages; ++i) {
+			partition->racache->pages[i].count = 0;
+			partition->racache->pages[i].sector = CACHE_FREE;
+		}
+	}
+
 	_FAT_unlock(&partition->lock);
 
 	return len;
Index: source/mem_allocate.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/mem_allocate.h,v
retrieving revision 1.2
diff -u -w -r1.2 mem_allocate.h
--- source/mem_allocate.h	20 Nov 2008 05:22:24 -0000	1.2
+++ source/mem_allocate.h	21 Dec 2008 03:20:58 -0000
@@ -37,6 +37,11 @@
 	return malloc (size);
 }
 
+static inline void* _FAT_mem_allocate_aligned(size_t alignment, size_t size)
+{
+	return memalign(alignment, size);
+}
+
 static inline void _FAT_mem_free (void* mem) {
 	free (mem);
 }
Index: source/partition.c
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/partition.c,v
retrieving revision 1.11
diff -u -w -r1.11 partition.c
--- source/partition.c	10 Dec 2008 14:26:58 -0000	1.11
+++ source/partition.c	21 Dec 2008 03:20:58 -0000
@@ -214,6 +214,8 @@
 	// Create a cache to use
 	partition->cache = _FAT_cache_constructor (cacheSize, partition->disc);
 
+	partition->racache = NULL;
+
 	// Set current directory to the root
 	partition->cwdCluster = partition->rootDirCluster;
 	
@@ -239,6 +241,8 @@
 		nextFile = nextFile->nextOpenFile;
 	}
 	
+	_FAT_racache_free(partition->racache);
+
 	// Free memory used by the cache, writing it to disc at the same time
 	_FAT_cache_destructor (partition->cache);
 
@@ -262,3 +266,13 @@
 	
 	return (PARTITION*)devops->deviceData;
 }
+
+#ifdef READAHEAD_CACHE
+bool fatEnableReadAhead(const char *path, u32 numPages, u32 pageSize)
+{
+	PARTITION *partition = _FAT_partition_getPartitionFromPath(path);
+        if (!partition) return false;
+	partition->racache = _FAT_racache_init(numPages, pageSize);
+	return true;
+}
+#endif
Index: source/partition.h
===================================================================
RCS file: /cvsroot/devkitpro/libfat/source/partition.h,v
retrieving revision 1.5
diff -u -w -r1.5 partition.h
--- source/partition.h	10 Dec 2008 14:26:58 -0000	1.5
+++ source/partition.h	21 Dec 2008 03:20:58 -0000
@@ -50,6 +50,7 @@
 typedef struct {
 	const DISC_INTERFACE* disc;
 	CACHE*                cache;
+	readahead_cache*      racache;
 	// Info about the partition
 	FS_TYPE               filesysType;
 	uint64_t              totalSize;
